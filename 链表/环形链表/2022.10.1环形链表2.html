<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 力扣142题
        function ListNode(val,next){
            this.val = (val==undefined?0:val)
            this.next = (next==undefined?null:next)

           
        }
        var detectCycle = function(head) {
                let slow = head
                let fast = head
                while(fast!==null&&fast.next!==null){
                    fast = fast.next.next
                    slow = slow.next
                    if(slow==fast){
                        let index1 = fast
                        let index2 = head
                        while(index1!==index2){
                            index1 = index1.next
                            index2 = index2.next
                        }
                        return index1
                    }
                }
                return null
                
        };


        /* 
            可以使用快慢指针法，分别定义 fast 和 slow 指针，
            从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

            假设从头结点到环形入口节点的节点数为x.环形入口节点到fast指针与slow指针相遇节点节点数为y.从相遇节点再到环形入口节点节点数为z。
            slow指针的移动距离为x+y
            fast指针的移动距离为x+y+n(y+z)
            n为fast指针走过的圈数
            由于slow指针一定会在进入环的第一圈被追上,所以slow指针走过的距离必为x+y
            由于时间相等,所以有以下等式
            2(x+y)=x+y+n(y+z)
            x = n(y+z)-y
            x = n(y+z)-y-z+z
            x = (n-1)(y+z)+z
            当n为1时,x=z
            这就意味着,从头结点出发一个指针,从相遇节点也出发一个指针,这两个指针每次只走一个节点,那么当这两个指针相遇的时候就是环形入口的节点。
            也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。
            让index1和index2同时移动，每次移动一个节点，那么他们相遇的地方就是环形入口的节点。
        */
    </script>
</body>
</html>